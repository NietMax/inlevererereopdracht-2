def evaluate_individual(activation_function, hidden_layer_size, solver):
    clf = MLPClassifier(hidden_layer_sizes=(hidden_layer_size,), activation=activation_function, solver=solver, max_iter=5000, random_state=42)
    clf.fit(X_train, y_train)
    accuracy = clf.score(X_test, y_test)
    return accuracy

def genetic_algorithm(population_size, generations):
    population = []

    for _ in range(population_size):
        activation_function = np.random.choice(activation_functions)
        hidden_layer_size = np.random.choice(hidden_layer_sizes)
        solver = np.random.choice(solvers)
        individual = (activation_function, hidden_layer_size, solver)
        population.append(individual)

    for generation in range(generations):
        scores = [evaluate_individual(activation_function, hidden_layer_size, solver) for activation_function, hidden_layer_size, solver in population]
        selected_indices = np.argsort(scores)[::-1][:int(population_size * 0.2)]
        selected_population = [population[i] for i in selected_indices]

        new_population = []
        for _ in range(population_size):
            index1, index2 = np.random.choice(len(selected_population), size=2, replace=False)
            parent1 = selected_population[index1]
            parent2 = selected_population[index2]
            parent1_activation_function, parent1_hidden_layer_size, parent1_solver = parent1
            parent2_activation_function, parent2_hidden_layer_size, parent2_solver = parent2
            child = (parent1_activation_function, parent2_hidden_layer_size, parent2_solver)
            new_population.append(child)

        population = new_population

    best_individual = max(population, key=lambda ind: evaluate_individual(ind[0], ind[1], ind[2]))
    return best_individual
